#! /bin/bash
# BASH prompt hacking
# See bash_prompt.md for details.

# For machines that are not running at least BASH version 4, just silently
# exit.
if [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
    return 0
fi

function __my_prompt_sshagent_string {
    if type -p __my_ssh_agent_prompt_string > /dev/null; then
	__my_ssh_agent_prompt_string
    fi
}

# Optionally print the gitbranch portion of the prompt
function __my_prompt_print_gitbranch {
    [ "${2-}" ] && printf "$@"
}

# Just like (format t "~&")
## UNUSED (for now)
function __my_prompt_format_tilde_ampersand {
    local curpos
    echo -en "\E[6n"
    IFS=";" read -sdR -a curpos
    ((curpos[1]!=1)) && echo -e '\E[1m\E[41m\E[33m%\E[0m'
}

trap '__previous_command=$__this_command; __this_command=$BASH_COMMAND' DEBUG

__my_prompt_cached_pwd=
__my_prompt_cached_gitbranch=

# This is the value of PROMPT_COMMAND, executed before the prompt is printed.
# We set PS1 here rather than running functions in the prompt because
# each time you use $(...) in PS1 you get a new subshell.  That makes
# using shell variables USELESS, and I want to use shell variables
# to cache things, to make consing up a new prompt faster.  Cygwin can
# be slow.
function __my_prompt_prompt_command {
    local pwd_changed
    local agent
    local gitbranch
    if [ "${__my_prompt_cached_pwd}" -a '(' "${__my_prompt_cached_pwd}" = "$PWD" ')' ]; then
	pwd_changed=
	# See if we changed the prompt:
	if [[ "${__previous_command}" =~ 'git checkout' ]]; then
	    pwd_changed=xxx
	fi
    else
	pwd_changed=xxx
    fi

    if [ ! "${__my_prompt_cached_gitbranch}" -o '(' -n "$pwd_changed" ')' ]; then
	if git rev-parse --git-dir >/dev/null 2>&1; then
	    __my_prompt_cached_gitbranch=$(git symbolic-ref -q HEAD 2>/dev/null | sed 's,refs/heads/,,')
	fi
    fi

    agent="$(__my_prompt_sshagent_string)"
    gitbranch="$(__my_prompt_print_gitbranch '[git:%s]' ${__my_prompt_cached_gitbranch})"

    PS1="$agent\\h$gitbranch"

    userchar='$'
    if [ "${WINDIR-}" ]; then
	if net session > /dev/null 2>&1; then
	    userchar='#'
	fi
    elif [ "$(id -u)" = 0 ]; then
        userchar='#'
    fi
    export PS1="$PS1$userchar "

    # First time only, fire off the env-setting function below
    if [ ! "$__my_prompt_cached_pwd" ]; then
	cd .
    fi
    __my_prompt_cached_pwd=$PWD

    # This tries to ensure that the prompt is printed at the beginning
    # of a new line, but I could not get this to work, so it is
    # disabled for now.
    #__my_prompt_format_tilde_ampersand
}

# "If set, the value is executed as a command prior to issuing
# each primary prompt."
PROMPT_COMMAND=__my_prompt_prompt_command

# If the current directory is an ACL binary directory, then
# source env.sh to setup the build environment.
function __do_acl_build_env_setup {
    [ -f makefile.m -a -f env.sh -a -f ../makefile.top ] && source env.sh
}

# usage: __my_localize_path path
#  return a local version of PATH if it uses NFS to access a resource
#  on the same machine, as given by $MACH.
function __my_localize_path {
    # lockf(3) doesn't work on FreeBSD on an NFS-mounted filesystem, so
    # remove the /net/<host> so ACL tests work on FreeBSD, when on
    # the <host>.  This solution works quite nicely with directory tracking
    # in Emacs.  See also scm-bin/fiemacsclient for hacks to handle the
    # case where emacs and emacsclient are run on different machines.
    local dir="$1"

    if [ ! -e "$dir" ]; then
	echo $dir does not exist 1>&2
	return 1
    fi

    # This is specific to me.  I use symlinks in ~/l/ to find various
    # things.
    if [[ "$dir" =~ ^$HOME/l/ ]]; then
	dir="$(readlink "$dir")"
	if [ ! -e "$dir" ]; then
	    echo expansion points to nonexistent $dir 1>&2
	    return 1
	fi
    fi

    if [[ "$dir" =~ ^/net/([^/]+)(/.*) ]]; then
	if [ "${BASH_REMATCH[1]}" = "$MACH" ]; then
	    dir="${BASH_REMATCH[2]}"
	    echo "[ using local path: $dir ]" 1>&2
	fi
    fi
    echo "$dir"
}

function cd {
    local dir
    local args
    if [ $# -eq 0 ]; then
	# accessing $HOME via NFS sucks!
	dir="$HOME"
	args=
    else
	local n=$(( ${#@} - 1 ))
	args="${@:1:$n}"
	dir="${@: -1}"
    fi
    if dir="$(__my_localize_path "$dir")"; then
	builtin cd $args "$dir" && __do_acl_build_env_setup
    fi
}

function pushd {
    if [ $# -eq 0 ]; then
	builtin pushd && __do_acl_build_env_setup
    elif [[ $1 =~ ^[-+] ]]; then
	builtin pushd $1 && __do_acl_build_env_setup
    else
	local n=$(( ${#@} - 1 ))
	local args="${@:1:$n}"
	local dir="${@: -1}"
	if dir="$(__my_localize_path "$dir")"; then
	    builtin pushd $args "$dir" && __do_acl_build_env_setup
	fi
    fi
}

function popd {
    builtin popd "$@" && __do_acl_build_env_setup
}
