#! /bin/bash
# Decide when and where to run an SSH agent.
# See the discussion in bink/bash_sshagent.txt.

# uncomment to turn on debugging
#set -x

# For machines that are not running at least BASH version 4, just silently
# exit, since the code here uses >=4 features.
if [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
    return 0
fi

# Allow scripts to turn this off.
[ "${INHIBIT_SSH_AGENT-}" ] && return

#################### sanity checks

if ! type -p __my_ssh_run_agent_p > /dev/null; then
    # Silently return, as this machine likely is running a BASH
    # before version 4.
    return
fi
if [ ! "${__my_ssh_default_identity-}" ]; then
    echo ABORT: __my_ssh_default_identity is not defined 1>&2
    return
fi
if [ ! "${__my_ssh_default_identity_md5-}" ]; then
    echo ABORT: __my_ssh_default_identity_md5 is not defined 1>&2
    return
fi
# Make sure these two variables have the same number of space-separated
# values.
if [ ${#__my_ssh_default_identity[@]} != ${#__my_ssh_default_identity_md5[@]} ]
then
    cat <<EOF
ABORT: __my_ssh_default_identity and __my_ssh_default_identity_md5
       have a different number of elements.  Fix this to enable
       agent handling.
EOF
    return
fi

if [ ! -d $HOME/tmp ]; then
    mkdir $HOME/tmp
    # By default it should be secure against snooping, since we put
    # agent info there.
    chmod 700 $HOME/tmp
fi

#################### ...sanity checks

# Info saved about an agent we start here goes into this file:
__my_agent_info="$HOME/tmp/agent.info"

# Info saved about a forwarded agent goes into this file, for use by
# scripts and cron jobs:
__my_agent_info2="$HOME/tmp/agent.info2"

# Return true if there is at least 1 key in the agent.
function __my_ssh_have_one_identity_p {
    if ssh-add -l &>/dev/null; then
	return 0
    else
	return 1
    fi
}
# If my default identity is not already added to the agent, then add it.
function __my_ssh_ensure_default_identities {
    local ids=(${__my_ssh_default_identity})
    local fps=(${__my_ssh_default_identity_md5})
    local n=${#ids[@]}
    local i=0
    while [ $i -lt $n ]; do
	if ! ssh-add -E md5 -l 2>/dev/null | grep -q ${fps[$i]}; then
	    echo NOTE: adding identity ${ids[$i]} 1>&2
	    ssh-add ${ids[$i]} || echo COULD NOT ADD IDENTITY 1>&2
	fi
	i=$(( i + 1 ))
    done
}

__my_ssh_have_lsof=
type -p lsof > /dev/null && __my_ssh_have_lsof=xxx
__my_ssh_have_ss=
type -p ss > /dev/null && __my_ssh_have_ss=xxx

# Return true if SSH_AUTH_SOCK is connected to a running process.
# Try ss first, then lsof.  ss is more reliable, I have found.
function __my_ssh_auth_sock_valid_p {
    local usock=$SSH_AUTH_SOCK
    [ -L $usock ] && usock=$(readlink $usock)

    if [ "${__my_ssh_have_ss}" ]; then
	if ss -l | grep -q $usock; then
	    return 0
	fi
	# fall through...
    fi
	
    if [ "${__my_ssh_have_lsof}" ]; then
	if lsof -a -U -u$USER 2>/dev/null | grep -q $usock; then
	    return 0
	fi
	# fall through...
    fi
    return 1
}

# Return true if an agent is running, false otherwise.
# Used by .bash_prompt.
function __my_ssh_connected_to_agent_p {
    # If we have a PID, then make sure it's valid
    if [ "${SSH_AGENT_PID-}" ]; then
	if ps -p $SSH_AGENT_PID > /dev/null; then
	    __my_ssh_have_one_identity_p && return 0
	else
	    return 1
	fi
    fi

    # Check for a forwarded agent
    [ "${SSH_AUTH_SOCK}" ] && [ -r "${SSH_AUTH_SOCK}" ] && {
	# An agent might be running.
	# Before returning success, if there is at least one
	# identity and we're on my home machine, then save
	# the SSH_AUTH_SOCK value so cron can use it.

	__my_ssh_auth_sock_valid_p || return 1
	    
	if __my_ssh_have_one_identity_p; then
	    # We have an identity, so the connection to the agent
	    # must be valid.
	    __my_ssh_run_agent_p && {
		# A forwarded agent is on my home machine, so
		# save the SSH_AUTH_SOCK for use by cron jobs.
		echo "export SSH_AUTH_SOCK=${SSH_AUTH_SOCK}" \
		     > ${__my_agent_info2}
	    }
	    return 0
	else
	    rm -f ${__my_agent_info2}
	fi
    }

    # assume it is not running
    return 1
}

function __my_ssh_agent_prompt_string {
    __my_ssh_connected_to_agent_p || return 0
    if __my_ssh_have_one_identity_p; then
	echo -n "@"
    else
	echo -n "-"
    fi
}

###############################################################################
# Exit this script if it is not running on a machine I sit at.
# The Windows machines are in this list because I use RDP to get to them,
# and that qualifies as "sitting at", since RDP doesn't take over any
# environment from the originating host.
#
# This is not done earlier in this script because the functions defined
# above are used in the construction of the prompt string.

__my_ssh_run_agent_p || return
###############################################################################

# Either connect to an exiting or start a new SSH agent.
function __my_ssh_initialize_agent {
    # IMPORTANT:
    #   We MUST check for a forwarded agent first, otherwise we might
    #   needlessly create locally running agents.

    # Check for a saved forwarded agent info.  This is only used
    # when running scripts from cron.
    if [ -f "${__my_agent_info2}" ]; then
	source ${__my_agent_info2} > /dev/null

	__my_ssh_connected_to_agent_p && return 0
	
	echo NOTE: ${__my_agent_info2} is stale, removing 1>&2
	rm -f ${__my_agent_info2} 
    fi

    if [ -f "${__my_agent_info}" ]; then
	source ${__my_agent_info} > /dev/null

	__my_ssh_connected_to_agent_p && return 0

	echo NOTE: ${__my_agent_info} is stale, removing 1>&2
	rm -f ${__my_agent_info} 
    fi

    # if we get here, we could not connect to an agent, so start one...

    ssh-agent -s > ${__my_agent_info} &&
    source ${__my_agent_info} > /dev/null &&
    echo NOTE: start new SSH agent: PID=$SSH_AGENT_PID 1>&2
    chmod 600 ${__my_agent_info}
}

###############################################################################

__my_ssh_connected_to_agent_p || __my_ssh_initialize_agent

__my_ssh_ensure_default_identities
