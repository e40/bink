#! /bin/bash
# Decide when and where to run an SSH agent.
# See the discussion in bink/bash_sshagent.md.

# NOTE: SSH_AUTH_SOCK, when created by a forwarded agent, is only
#       good for the duration of the ssh command that set it.  Once
#       that command exits, the SSH_AUTH_SOCK value is no longer valid.
#       It does no good to save this value and use it later.

# uncomment to turn on debugging
#set -x
# How to use MY_DEBUG_SSHAGENT:
# Server:
#  - put this into /etc/ssh/sshd_config
#    AcceptEnv MY_DEBUG_SSHAGENT
#  - send HUP signal to sshd process
# Client:
#   $ MY_DEBUG_SSHAGENT=xxx ssh -o SendEnv=MY_DEBUG_SSHAGENT gremlin date

[ "${MY_DEBUG_SSHAGENT-}" ] && set -x

# For machines that are not running at least BASH version 4, just silently
# exit, since the code here uses >=4 features.
if [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
    return 0
fi

# Allow scripts to turn this off.
[ "${INHIBIT_SSH_AGENT-}" ] && return

# Abort when using sudo
[ "${__my_ssh_agent_user-}" ] && 
    [ "${USER}" != "${__my_ssh_agent_user}" ] &&
    return

#################### sanity checks

if ! type -p __my_ssh_run_agent_p > /dev/null; then
    # Silently return, as this machine likely is running a BASH
    # before version 4.
    return
fi
if [ ! "${__my_ssh_default_identity-}" ]; then
    echo ABORT: __my_ssh_default_identity is not defined 1>&2
    return
fi
if [ ! "${__my_ssh_default_identity_md5-}" ]; then
    echo ABORT: __my_ssh_default_identity_md5 is not defined 1>&2
    return
fi
# Make sure these two variables have the same number of space-separated
# values.
if [ ${#__my_ssh_default_identity[@]} != ${#__my_ssh_default_identity_md5[@]} ]
then
    cat <<EOF
ABORT: __my_ssh_default_identity and __my_ssh_default_identity_md5
       have a different number of elements.  Fix this to enable
       agent handling.
EOF
    return
fi

if [ ! -d $HOME/tmp ]; then
    mkdir $HOME/tmp
    # By default it should be secure against snooping, since we put
    # agent info there.
    chmod 700 $HOME/tmp
fi

#################### ...sanity checks

# Info saved about an agent we start here goes into this file:
__my_agent_info="$HOME/tmp/agent.info"

# Return true if there is at least 1 key in the agent.
function __my_ssh_have_one_identity_p {
    if ssh-add -l &>/dev/null; then
	[ "${MY_DEBUG_SSHAGENT-}" ] && echo have one identity: YES 1>&2
	return 0
    else
	[ "${MY_DEBUG_SSHAGENT-}" ] && echo have one identity: NO 1>&2
	return 1
    fi
}
# If my default identity is not already added to the agent, then add it.
function __my_ssh_ensure_default_identities {
    local ids=(${__my_ssh_default_identity})
    local fps=(${__my_ssh_default_identity_md5})
    local n=${#ids[@]}
    local i=0
    [ "${MY_DEBUG_SSHAGENT-}" ] && ssh-add -E md5 -l 1>&2
    while [ $i -lt $n ]; do
	if ! ssh-add -E md5 -l 2>/dev/null | grep -q ${fps[$i]}; then
	    echo NOTE: adding identity ${ids[$i]} 1>&2
	    ssh-add ${ids[$i]} || echo COULD NOT ADD IDENTITY 1>&2
	fi
	i=$(( i + 1 ))
    done
}

__my_ssh_have_lsof=
type -p lsof > /dev/null && __my_ssh_have_lsof=xxx
__my_ssh_have_ss=
type -p ss > /dev/null && __my_ssh_have_ss=xxx

# Return true if SSH_AUTH_SOCK is connected to a running process.
# Try ss first, then lsof.  ss is more reliable, I have found.
# If neither lsof nor ss are installed, we can't really test
# that the socket is valid, so return success in that case, and let
# our caller do other tests to check for a valid agent.
function __my_ssh_auth_sock_valid_p {
    # If the file does not exist and is not a socket, then we're done.
    [ -S "${SSH_AUTH_SOCK-}" ] || return 1

    # If lsof and ss are not installed, we're done.
    [ "${__my_ssh_have_ss}${__my_ssh_have_lsof}" ] || return 0 

    local usock=$SSH_AUTH_SOCK
    [ -L $usock ] && usock=$(readlink $usock)

    if [ "${__my_ssh_have_ss}" ]; then
	if ss -l | grep -q $usock; then
	    return 0
	fi
	# fall through...
    fi
	
    if [ "${__my_ssh_have_lsof}" ]; then
	if lsof -a -U -u$USER 2>/dev/null | grep -q $usock; then
	    return 0
	fi
	# fall through...
    fi
    return 1
}

# Return true if an agent is accessible, false otherwise.
function __my_connected_to_ssh_agent_p {
    if [ "${SSH_AGENT_PID-}" ]; then
	if ps -p $SSH_AGENT_PID > /dev/null; then
	    # the process is alive, assume it's OK
	    return 0
	else
	    [ "${MY_DEBUG_SSHAGENT-}" ] && NO AGENT 1>&2
	    # no process, but since the variable exists, return false
	    return 1
	fi
    fi
    # fall through: no SSH_AGENT_PID, check for a forwarded agent...

    __my_ssh_auth_sock_valid_p && return 0

    # no agent running or accessible
    [ "${MY_DEBUG_SSHAGENT-}" ] && NO AGENT 1>&2
    return 1
}

function __my_ssh_agent_prompt_string {
    __my_connected_to_ssh_agent_p || return 0
    if __my_ssh_have_one_identity_p; then
	echo -n "@"
    else
	echo -n "-"
    fi
}

###############################################################################
# Exit this script if it is not running on a machine I sit at.
# The Windows machines are in this list because I use RDP to get to them,
# and that qualifies as "sitting at", since RDP doesn't take over any
# environment from the originating host.
#
# This is not done earlier in this script because the functions defined
# above are used in the construction of the prompt string.

__my_ssh_run_agent_p || return
###############################################################################

# Either connect to an exiting SSH agent or start a new one.
function __my_ssh_initialize_agent {
    if [ -f "${__my_agent_info}" ]; then
	source ${__my_agent_info} > /dev/null

	__my_connected_to_ssh_agent_p && return 0

	echo NOTE: ${__my_agent_info} is stale, removing 1>&2
	rm -f ${__my_agent_info} 
    fi

    # if we get here, we could not connect to an agent, so start one

    ssh-agent -s > ${__my_agent_info} &&
	source ${__my_agent_info} > /dev/null &&
	echo NOTE: start new SSH agent: PID=$SSH_AGENT_PID 1>&2
    chmod 600 ${__my_agent_info}
}

###############################################################################

__my_connected_to_ssh_agent_p || __my_ssh_initialize_agent

__my_ssh_ensure_default_identities
