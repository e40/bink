#! /bin/bash
# Decide when and where to run an SSH agent.
# See the discussion in bink/bash_sshagent.md.

# NOTE: SSH_AUTH_SOCK, when created by a forwarded agent, is only
#       good for the duration of the ssh command that set it.  Once
#       that command exits, the SSH_AUTH_SOCK value is no longer valid.
#       It does no good to save this value and use it later.

# How to use MY_DEBUG_SSHAGENT:
# Server:
#  - put this into /etc/ssh/sshd_config
#    AcceptEnv MY_DEBUG_SSHAGENT
#  - send HUP signal to sshd process
# Client:
#   $ MY_DEBUG_SSHAGENT=xxx ssh -o SendEnv=MY_DEBUG_SSHAGENT gremlin date

[ "${MY_DEBUG_SSHAGENT-}" ] && _debug_on sshagent
## or unconditionally:
#_debug_on sshagent
## or MAX debug
#set -x

# For machines that are not running at least BASH version 4, just silently
# exit, since the code here uses >=4 features.
if [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
    return 0
fi

# Allow scripts to turn this off.
[ "${INHIBIT_SSH_AGENT-}" ] && return

# Abort when using sudo
[ "${__my_ssh_agent_user-}" ] && 
    [ "${USER}" != "${__my_ssh_agent_user}" ] &&
    return

#################### sanity checks

if ! type -p __my_ssh_run_agent_p > /dev/null; then
    # Silently return, as this machine likely is running a BASH
    # before version 4.
    return
fi
if [ ! "${__my_ssh_default_identity-}" ]; then
    echo ABORT: __my_ssh_default_identity is not defined 1>&2
    return
fi
if [ ! "${__my_ssh_default_identity_md5-}" ]; then
    echo ABORT: __my_ssh_default_identity_md5 is not defined 1>&2
    return
fi
# Make sure these two variables have the same number of space-separated
# values.
if [ ${#__my_ssh_default_identity[@]} != ${#__my_ssh_default_identity_md5[@]} ]
then
    cat <<EOF
ABORT: __my_ssh_default_identity and __my_ssh_default_identity_md5
       have a different number of elements.  Fix this to enable
       agent handling.
EOF
    return
fi

if [ ! -d $HOME/tmp ]; then
    mkdir $HOME/tmp
    # By default it should be secure against snooping, since we put
    # agent info there.
    chmod 700 $HOME/tmp
fi

#################### ...sanity checks

# Info saved about an agent we start here goes into this file:
__my_agent_info="$HOME/tmp/agent.info"

# Return true if there is at least 1 key in the agent.
function __my_ssh_have_one_identity_p {
    if ssh-add -l &>/dev/null; then
	_debug sshagent have one identity: YES
	return 0
    else
	_debug sshagent have one identity: NO
	return 1
    fi
}
# If my default identity is not already added to the agent, then add it.
function __my_ssh_ensure_default_identities {
    local ids=(${__my_ssh_default_identity})
    local fps=(${__my_ssh_default_identity_md5})
    local n=${#ids[@]}
    local i=0
    [ "${MY_DEBUG_SSHAGENT-}" ] && ssh-add -E md5 -l 1>&2
    while [ $i -lt $n ]; do
	if ! ssh-add -E md5 -l 2>/dev/null | grep -q ${fps[$i]}; then
	    echo NOTE: adding identity ${ids[$i]} 1>&2
	    ssh-add ${ids[$i]} || echo COULD NOT ADD IDENTITY 1>&2
	fi
	i=$(( i + 1 ))
    done
}

# Return true if SSH_AUTH_SOCK is connected to an agent which
# is alive.  "ssh-add -l" will return 0 on success, 1 on failure
# (no identities) and 2 if the ssh-add is unable to contact the agent.
function __my_ssh_auth_sock_valid_p {
    # If the file does not exist and is not a socket, then we're done.
    [ ! -S "${SSH_AUTH_SOCK-}" ] && 
	_debug sshagent NO SSH_AUTH_SOCK &&
	return 1

    local ret=0
    ssh-add -l &> /dev/null || ret=$?
    [ $? -eq 2 ] &&
	_debug sshagent FAIL: ssh-add could not contact agent &&
	return 1
    _debug sshagent SUCCESS: ssh-add could contact agent
    return 0
}

# Return true if an agent is accessible, false otherwise.
function __my_connected_to_ssh_agent_p {
    if [ "${SSH_AGENT_PID-}" ]; then
	_debug sshagent Looking for PID $SSH_AGENT_PID
	if ps -p $SSH_AGENT_PID > /dev/null; then
	    # the process is alive, assume it's OK
	    return 0
	else
	    _debug sshagent SSH_AGENT_PID not found
	    # no process, but since the variable exists, return false
	    return 1
	fi
    fi
    # fall through: no SSH_AGENT_PID, check for a forwarded agent...

    __my_ssh_auth_sock_valid_p && return 0

    # no agent running or accessible
    _debug sshagent NO AGENT FOUND
    return 1
}

function __my_ssh_agent_prompt_string {
    __my_connected_to_ssh_agent_p || return 0
    if __my_ssh_have_one_identity_p; then
	echo -n "@"
    else
	echo -n "-"
    fi
}

###############################################################################
# Exit this script if it is not running on a machine I sit at.
# The Windows machines are in this list because I use RDP to get to them,
# and that qualifies as "sitting at", since RDP doesn't take over any
# environment from the originating host.
#
# This is not done earlier in this script because the functions defined
# above are used in the construction of the prompt string.

__my_ssh_run_agent_p || return
###############################################################################

# Either connect to an exiting SSH agent or start a new one.
function __my_ssh_initialize_agent {
    if [ -f "${__my_agent_info}" ]; then
	source ${__my_agent_info} > /dev/null

	__my_connected_to_ssh_agent_p && return 0

	echo NOTE: ${__my_agent_info} is stale, removing 1>&2
	rm -f ${__my_agent_info} 
    fi

    # if we get here, we could not connect to an agent, so start one

    ssh-agent -s > ${__my_agent_info} &&
	source ${__my_agent_info} > /dev/null &&
	echo NOTE: start new SSH agent: PID=$SSH_AGENT_PID 1>&2
    chmod 600 ${__my_agent_info}
}

###############################################################################

__my_connected_to_ssh_agent_p || __my_ssh_initialize_agent

__my_ssh_ensure_default_identities
