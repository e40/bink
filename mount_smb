#! /bin/bash
# On Mac OS X, mounts an SMB volume over an SSH tunnel.
# For more info, see the usage below.
#
###############################################################################
# Defaults with command-line overrides

# Initialize defaults from init file, if there is one:
[ -f $HOME/.mount_smb ] && source $HOME/.mount_smb

# The host to which we connect to create the tunnel:
: ${sshhost:=}

# The workgroup:
: ${workgroup:=}

# The host with the SMB shares we want to mount:
: ${smbhost:=}

# The name of the SMB share you want to mount:
: ${share:=}

# Assume the local and remote users are the same:
: ${remoteuser:=$USER}

# The SSH config to use
: ${sshconfig:=$HOME/.ssh/config}

# The SSH identity to use
: ${sshid:=$HOME/.ssh/id_dsa}

# If non-null, do not open a Finder window post mount
: ${noopen:=}

###############################################################################
set -eu

pidfileprefix="/tmp/autosshpid"

function errordie {
    echo "Error: $*" 1>&2
    exit 1
}

autossh="$(type -p autossh)" || errordie autossh: command not found
ssh="$(type -p ssh)" || errordie ssh: command not found
removepidfile="$(type -p removepidfile)" ||
    errordie removepidfile: command not found

function usage {
    cat 1>&2 <<EOF
Usage: mount_smb [--debug] [--user remote-user] [--no-finder-open]
                 [--sshconfig config]
                 [--sshidentity identity]
                 --sshhost sshhost --smbhost smbhost
                 --share name[,name2] --workgroup workgroup

On Mac OS X, mount an SMB share via an SSH tunnel.

The script pauses in the middle to let you use the volume,
then when you continue it dismounts and shuts down the tunnel.

Multiple instances of this script can run at a time, since each one
uses a new, local device and maps local ports 139 and 445 for that
device to the remote machine.

/etc/sudoers can be augmented, for easier operation.  Add these lines
to the end with the "visudo" command:
   Defaults        env_keep += "AUTOSSH_PIDFILE"
   $USER ALL=(ALL) NOPASSWD: /sbin/ifconfig lo0 *
   $USER ALL=(ALL) NOPASSWD: /opt/local/bin/autossh
   $USER ALL=(ALL) NOPASSWD: /usr/bin/ssh
   $USER ALL=(ALL) NOPASSWD: $removepidfile ${pidfileprefix}*

This script has been tested on Mac OS X 10.9.

Optional arguments:
 --user remote-user     :: defaults to \$USER
 --no-finder-open       :: do not open a Finder window, post mount
 --sshconfig config     :: defaults to \$HOME/.ssh/config
 --sshidentity identity :: defaults to \$HOME/.ssh/id_dsa

Required arguments:
 --sshhost sshhost        :: the SSH host, or the other end of the tunnel
 --smbhost smbhost        :: the SMB host, which is accessible to the SSH host.
                             The SMB host can be different than the SSH host.
 --workgroup workgroup    :: the SMB workgroup
 --share name[,name2,...] :: the SMB share to mount -- if multiple names
                             are given mount each one for the given smbhost

You can initialize the following command line arguments from
the script \$HOME/.mount_smb.  The command line to variable name mapping
is:
   --sshconfig      sshconfig
   --sshidentity    sshidentity
   --user           remoteuser
   --sshhost        sshhost
   --smbhost        smbhost
   --share          share
   --workgroup      workgroup
   --no-finder-open noopen

Lastly, if a BASH function named "mount_smb_post_mount" is defined,
perhaps in \$HOME/.mount_smb or \$HOME/.bashrc, then it is called 
post-mount, with arguments these arguments:

    mount_smb_post_mount "\$mountpoint" "\$smbhost" "\$share"

This can be used to do post-mount things, like displaying a particular
share with the Finder.  For example:

# When mounting share "john" on host "linuxhost", open the "incoming"
# subdirectory in the Finder.
function mount_smb_post_mount {
    local mountpoint=\${1-}
    local smbhost=\${2-}
    local share=\${3-}
    case "\$smbhost" in
	linuxhost) [ "\$share" = "john" ] && open \$mountpoint/incoming ;;
    esac
}
EOF
    exit 1
}

function errordie {
    if test -n "${*-}"; then
	echo "Error: $*" 1>&2
    fi
    exit 1
}

debug=

while test $# -gt 0; do
    case $1 in
	--debug)          debug=$1             ;;
	# deprecated, but still works:
	--folder)         share=$2;      shift ;;
	--share)          share=$2;      shift ;;
	--help)           usage                ;;
	--no-finder-open) noopen=$1            ;;
	--smbhost)        smbhost=$2;    shift ;;
	--sshconfig)      sshconfig=$2;  shift ;;
	--sshidentity)    sshid=$2;      shift ;;
	--sshhost)        sshhost=$2;    shift ;;
	--user)           remoteuser=$2; shift ;;
	--workgroup)      workgroup=$2;  shift ;;
	-*)     usage ;;
	*)      usage ;;
    esac
    shift
done

[ "$sshhost" ]   || errordie sshhost is not set, use --sshhost 
[ "$smbhost" ]   || errordie smbhost is not set, use --smbhost 
[ "$share" ]     || errordie share is not set, use --share 
[ "$workgroup" ] || errordie workgroup is not set, use --workgroup

shares="$(echo $share | sed 's/,/ /g')"

# Leave here for debugging:
: cat <<EOF
Parameters:
  sshhost=$sshhost
  workgroup=$workgroup
  smbhost=$smbhost
  remoteuser=$remoteuser
  sshconfig=$sshconfig
  sshid=$sshid
  share=$share

  shares=$shares
EOF

###############################################################################

function find_device {
    # Find the first unused lo0 IP address.
    local max=$(/sbin/ifconfig lo0 | \
		       grep "inet " \
		       | sed -e 's/.*inet 127\.0\.0\.//g' \
			     -e 's/ netmask.*//g' | \
		       sort -n | tail -1)
    echo 127.0.0.$(( $max + 1 ))
}

function read_encoded_password {
    local pass
    [ "${EMACS-}" ] || stty -echo
    read -p "Password:" -s pass
    [ "${EMACS-}" ] || stty echo
    python -c "import sys, urllib as ul; print ul.quote(\"$pass\")"
}

function set_password {
    echo "Enter your password for the SMB shares $smbhost:"
    password="$(read_encoded_password)"
    printf '\n'
}

function start_tunnel {
    # Using -o ControlPersist=yes causes the autossh to not stick around,
    # which is definitely not what we want, because the reconnect will not
    # happen across sleeping the OS.  However, not using it also causes
    # the autossh to stick around too long, after the ``-O exit'' is sent.
    # I'd rather autossh's accumulate in the background than the reconnect
    # not happen.
    #
    # To work around the above problem, we use AUTOSSH_PIDFILE and kill
    # it manually when the script exits.
    if ! sudo AUTOSSH_PIDFILE=$pidfile $autossh -M 0 \
	 -L ${device}:139:${smbhost}:139 \
	 -L ${device}:445:${smbhost}:445 \
	 -F $sshconfig -i $sshid \
	 -o ControlMaster=yes \
	 -o ControlPath=$socket \
	 -o ServerAliveInterval=10 \
	 -o ServerAliveCountMax=3 \
	 -o StrictHostKeyChecking=no \
	 -N -f \
	 $USER@$sshhost
    then
	# We get here for a bad password
	if ! sudo $ifconfig lo0 ${device} -alias down; then
	    echo $ifconfig -alias down failed
	fi
	errordie autossh failed
    fi
}

function stop_tunnel_and_cleanup {
    for mountpoint in $mountpoints; do
	if ! umount $mountpoint; then
	    echo umount $mountpoint failed
	fi
	# Give the volume time to unmount:
	sleep 2
	if [ -d $mountpoint ]; then
	    # Only true if there was an error, I beleive.  Under normal
	    # conditions, umount removes the directory.
	    if ! rmdir $mountpoint; then
		echo rmdir $mountpoint failed
	    fi
	fi
    done

    if ! sudo $ifconfig lo0 ${device} -alias down; then
	echo $ifconfig -alias down failed
    fi

    # do this last (so no need to error protect it)
    if [ -e $socket ]; then
	sshargs="$USER@$sshhost -F $sshconfig -i $sshid -S $socket "
	echo Shutting down ssh...
	sudo $ssh $sshargs -O exit
	echo Killing autossh
	sudo $removepidfile $pidfile
    else
	echo Warning: autossh socket does not exist, cannot shut it down
    fi
}

function mount_shares {
    local mountpoint

    set_password
    
    for share in $shares; do
	mountpoint="/Volumes/$smbhost-$share"
	mountpoints="$mountpoints $mountpoint"

	mkdir -p $mountpoint

	while ! /sbin/mount_smbfs \
		"//${workgroup};${remoteuser}:${password}@${device}/${share}" \
		$mountpoint
	do
	    # Assume it failed because the password was incorrect
	    set_password
	done

	# If a function named "mount_smb_post_mount" was defined in
	# $HOME/.mount_smb (or possibly in $HOME/.bashrc), then call it.
	# It can be used to do post-mount things, like displaying a particular
	# share with the Finder.
	if [ "$(type -t mount_smb_post_mount)" = "function" ]; then
	    mount_smb_post_mount "$mountpoint" "$smbhost" "$share"
	elif [ "$noopen" ]; then
	    : # do nothing
	else
	    # Open a Finder on it
	    open $mountpoint
	fi
    done
}

###############################################################################

# We put the main body of code in a list {} so that if the script is
# modified after it starts it won't cause problems.
{
    password=

    mountpoints=

    ifconfig=/sbin/ifconfig

    # This file is removed by ssh once the control socket is shutdown
    socket=/tmp/smbtunnel$$
    pidfile=${pidfileprefix}$$

    if device=$(find_device); then
	if [ ! "$device" ]; then
	    errordie Could not find device
	fi
    else
	errordie Could not find device
    fi

    sudo $ifconfig lo0 ${device} alias up

    start_tunnel
    trap "stop_tunnel_and_cleanup" 0

    echo Waiting for tunnel to initialize on ${device}
    sleep 5
    [ -e $socket ] || errordie autossh did not create $socket file

    mount_shares

    cat <<EOF
When you are done with the share, press ENTER and it will be unmounted
EOF
    read foo

    # the cleanup is done in the trap handler
    exit
}
