#! /bin/bash
# On Mac OS X, mounts an SMB volume over an SSH tunnel.  It uses autossh
# to insure the connection stays open, say, across sleeping a laptop.
# For more info, see the usage below.
#  
###############################################################################
# Defaults with command-line overrides

# Initialize defaults from init file, if there is one:
[ -f $HOME/.mount_smb ] && source $HOME/.mount_smb

# The host to which we connect to create the tunnel:
: ${sshhost:=}

# The workgroup:
: ${workgroup:=}

# The host with the SMB shares we want to mount:
: ${smbhost:=}

# The name of the SMB share you want to mount:
: ${share:=}

# Assume the local and remote users are the same:
: ${remoteuser:=$USER}

# The SSH config to use
: ${sshconfig:=$HOME/.ssh/config}

# The SSH identity to use
: ${sshid:=$HOME/.ssh/id_dsa}

# If non-null, do not open a Finder window post mount
: ${noopen:=}

# If non-null, be verbose
: ${debug:=}

###############################################################################
set -eu

pidfileprefix="/tmp/autosshpid"

function errordie {
    echo "Error: $*" 1>&2
    exit 1
}

autossh="$(type -p autossh)" || errordie autossh: command not found
ssh="$(type -p ssh)" || errordie ssh: command not found
removepidfile="$(type -p removepidfile)" ||
    errordie removepidfile: command not found

function usage {
    cat 1>&2 <<EOF
Usage: mount_smb [--debug] [--user remote-user] [--no-finder-open]
                 [--sshconfig config]
                 [--sshidentity identity]
                 --sshhost sshhost --smbhost smbhost
                 --share name[,name2] --workgroup workgroup

On Mac OS X, mount an SMB share via an SSH tunnel.  It uses autossh
to ensure the connection stays open, even in the face of sleeping a laptop
or interrupted network connections.

The script pauses in the middle to let you use the volume,
then when you continue it dismounts and shuts down the tunnel.

It uses "sudo" so you either need to supply the password or add to
/etc/sudoers for password-less operation.

Multiple instances of this script can run at a time, since each one
uses a new, local device and maps local ports 139 and 445 for that
device to the remote machine.

/etc/sudoers changes for password-less operation are below, which 
should be added with the "visudo" command as root:
   Defaults        env_keep += "AUTOSSH_PIDFILE"
   $USER ALL=(ALL) NOPASSWD: /sbin/ifconfig lo0 *
   $USER ALL=(ALL) NOPASSWD: /opt/local/bin/autossh
   $USER ALL=(ALL) NOPASSWD: /usr/bin/ssh
   $USER ALL=(ALL) NOPASSWD: $removepidfile ${pidfileprefix}*

This script has been tested on Mac OS X 10.9.

Optional arguments:
 --user remote-user     :: defaults to \$USER
 --no-finder-open       :: do not open a Finder window, post mount
 --sshconfig config     :: defaults to \$HOME/.ssh/config
 --sshidentity identity :: defaults to \$HOME/.ssh/id_dsa

Required arguments:
 --sshhost sshhost        :: the SSH host, or the other end of the tunnel
 --smbhost smbhost        :: the SMB host, which is accessible to the SSH host.
                             The SMB host can be different than the SSH host.
 --workgroup workgroup    :: the SMB workgroup
 --share name[,name2,...] :: the SMB share to mount -- if multiple names
                             are given mount each one for the given smbhost

You can initialize the following command line arguments from
the script \$HOME/.mount_smb.  The command line to variable name mapping
is:
   --sshconfig      sshconfig
   --sshidentity    sshidentity
   --user           remoteuser
   --sshhost        sshhost
   --smbhost        smbhost
   --share          share
   --workgroup      workgroup
   --no-finder-open noopen
   --debug          debug

In this script, two BASH functions have significance:

If "mount_smb_post_mount" is defined, it is called 
post-mount, with arguments these arguments:

    mount_smb_post_mount "\$mountpoint" "\$smbhost" "\$share"

It can be used to do post-mount things, like displaying a particular
share with the Finder.  For example:

# When mounting share "john" on host "linuxhost", open the "incoming"
# subdirectory in the Finder.
function mount_smb_post_mount {
    local mountpoint=\${1-}
    local smbhost=\${2-}
    local share=\${3-}
    case "\$smbhost" in
	linuxhost) [ "\$share" = "john" ] && open \$mountpoint/incoming ;;
    esac
}

If "mount_smb_timer" is defined, it is called every minute post-mount with
these arguments:

    mount_smb_timer \$minutes_since_mount

It can be used to open network access after a set period of time elapses,
for example.
EOF
    exit 1
}

function errordie {
    if test -n "${*-}"; then
	echo "Error: $*" 1>&2
    fi
    exit 1
}

function debug {
    [ "$debug" ] && echo "$(date "+%Y-%m-%d %H:%M:%S"): $@"
}

while test $# -gt 0; do
    case $1 in
	--debug)          debug=$1             ;;
	# deprecated, but still works:
	--folder)         share=$2;      shift ;;
	--share)          share=$2;      shift ;;
	--help)           usage                ;;
	--no-finder-open) noopen=$1            ;;
	--smbhost)        smbhost=$2;    shift ;;
	--sshconfig)      sshconfig=$2;  shift ;;
	--sshidentity)    sshid=$2;      shift ;;
	--sshhost)        sshhost=$2;    shift ;;
	--user)           remoteuser=$2; shift ;;
	--workgroup)      workgroup=$2;  shift ;;
	-*)     usage ;;
	*)      usage ;;
    esac
    shift
done

[ "$sshhost" ]   || errordie sshhost is not set, use --sshhost 
[ "$smbhost" ]   || errordie smbhost is not set, use --smbhost 
[ "$share" ]     || errordie share is not set, use --share 
[ "$workgroup" ] || errordie workgroup is not set, use --workgroup

shares="$(echo $share | sed 's/,/ /g')"

# Leave here for debugging:
: cat <<EOF
Parameters:
  sshhost=$sshhost
  workgroup=$workgroup
  smbhost=$smbhost
  remoteuser=$remoteuser
  sshconfig=$sshconfig
  sshid=$sshid
  share=$share

  shares=$shares
EOF

###############################################################################

function find_device {
    # Find the first unused lo0 IP address.
    local max=$(/sbin/ifconfig lo0 | \
		       grep "inet " \
		       | sed -e 's/.*inet 127\.0\.0\.//g' \
			     -e 's/ netmask.*//g' | \
		       sort -n | tail -1)
    echo 127.0.0.$(( $max + 1 ))
}

function read_encoded_password {
    local pass
    [ "${EMACS-}" ] || stty -echo
    read -p "Password:" -s pass
    [ "${EMACS-}" ] || stty echo
    python -c "import sys, urllib as ul; print ul.quote(\"$pass\")"
}

password=

function set_password {
    if [ ! "$password" ]; then
	echo "Enter your password for the SMB shares $smbhost:"
	password="$(read_encoded_password)"
	printf '\n'
    fi
}

function device_up {
    debug binding $device...
    sudo $ifconfig lo0 ${device} alias up
}

function device_down {
    debug unbinding $device...
    if ! sudo $ifconfig lo0 ${device} -alias down; then
	echo $ifconfig -alias down failed
    fi
}

function start_tunnel {
    device_up
    
    # Using -o ControlPersist=yes causes the autossh to not stick around,
    # which is definitely not what we want, because the reconnect will not
    # happen across sleeping the OS.  However, not using it also causes
    # the autossh to stick around too long, after the ``-O exit'' is sent.
    # I'd rather autossh's accumulate in the background than the reconnect
    # not happen.
    #
    # To work around the above problem, we use AUTOSSH_PIDFILE and kill
    # it manually when the script exits.
    if ! sudo AUTOSSH_PIDFILE=$pidfile $autossh -M 0 \
	 -L ${device}:139:${smbhost}:139 \
	 -L ${device}:445:${smbhost}:445 \
	 -F $sshconfig -i $sshid \
	 -o ControlMaster=yes \
	 -o ControlPath=$socket \
	 -o ServerAliveInterval=10 \
	 -o ServerAliveCountMax=3 \
	 -o StrictHostKeyChecking=no \
	 -N -f \
	 $USER@$sshhost
    then
	debug autossh failed
	device_down
	return 1
    fi

    trap "stop_tunnel_and_cleanup" 0

    debug waiting for tunnel to initialize on ${device}
    sleep 5
    if [ ! -e $socket ]; then
	debug autossh did not create $socket file...
	device_down
	return 1
    fi
}

function start_tunnel_retry {
    # try 5 times to start the tunnel
    local n=${1-5}
    local status
    while [ $n -gt 0 ]; do
	debug "start tunnel..."
	if ! start_tunnel; then
	    debug tunnel did not start, try again
	    n=$(( $n - 1 ))
	    status=1
	else
	    status=0
	fi
	break
    done
    return $status
}

function stop_tunnel_and_cleanup {
    for mountpoint in $mountpoints; do
	# can't test the directory's existence the standard way because
	# this will cause the script to hang.  Use the `mount' command.
	if mount | grep -q $mountpoint; then
	    debug $mountpoint is mounted
	    if umount $mountpoint; then
		debug $mountpoint unmounted
	    else
		errordie umount $mountpoint failed
	    fi
	else
	    debug $mountpoint is not mounted
	fi

	# Give the volume time to unmount
	sleep 2
    done

    if ! sudo $ifconfig lo0 ${device} -alias down; then
	debug $ifconfig -alias down failed
    fi

    # do this last (so no need to error protect it)
    if [ -e $socket ]; then
	sshargs="$USER@$sshhost -F $sshconfig -i $sshid -S $socket "
	debug shutting down ssh...
	sudo $ssh $sshargs -O exit
	debug killing autossh
	sudo $removepidfile $pidfile
    else
	debug warning: autossh socket does not exist, cannot shut it down
	# get rid of the pidfile, at least
	sudo $removepidfile $pidfile
    fi
}

function mount_shares {
    local mountpoint

    set_password
    
    for share in $shares; do
	mountpoint="/Volumes/$smbhost-$share"
	mountpoints="$mountpoints $mountpoint"

	mkdir -p $mountpoint

	while ! /sbin/mount_smbfs \
		"//${workgroup};${remoteuser}:${password}@${device}/${share}" \
		$mountpoint
	do
	    # Assume it failed because the password was incorrect
	    set_password
	done

	# If a function named "mount_smb_post_mount" was defined in
	# $HOME/.mount_smb (or possibly in $HOME/.bashrc), then call it.
	# It can be used to do post-mount things, like displaying a particular
	# share with the Finder.
	if [ "$(type -t mount_smb_post_mount)" = "function" ]; then
	    mount_smb_post_mount "$mountpoint" "$smbhost" "$share"
	elif [ "$noopen" ]; then
	    : # do nothing
	else
	    # Open a Finder on it
	    open $mountpoint
	fi
    done

    announce
}

function announce {
    cat <<EOF

When you are done with the share, press ENTER and it will be unmounted
EOF
}

# Increment the minute timer and possibly call the mount_smb_timer function
# defined by the user, which might do something like knock.
min=1
function incf_min {
    min=$(( $min + 1 ))
    if [ "$(type -t mount_smb_timer)" = "function" ]; then
	mount_smb_timer $min
    fi
}

###############################################################################

# We put the main body of code in a list {} so that if the script is
# modified after it starts it won't cause problems.
{
    if [ "$(type -t mount_smb_usersetup)" = "function" ]; then
	mount_smb_usersetup
    fi

    password=

    mountpoints=

    ifconfig=/sbin/ifconfig

    # This file is removed by ssh once the control socket is shutdown
    socket=/tmp/smbtunnel$$
    pidfile=${pidfileprefix}$$

    if device=$(find_device); then
	if [ ! "$device" ]; then
	    errordie Could not find device
	fi
    else
	errordie Could not find device
    fi

    start_tunnel_retry 5

    mount_shares

    while true; do
	# wake up every 60 seconds to see if $socket exists
	if read -t 60 foo; then
	    # User typed something
	    break
	else
	    incf_min
	    # If the socket disappears that means the ssh that autossh
	    # started died, due to a network outage or something similar.
	    # Wait for it to come back.
	    oknow=
	    while [ ! -e "$socket" ]; do
		debug waiting for $socket to reappear...
		sleep 60
		incf_min
		oknow=xxx
	    done
	    if [ "$oknow" ]; then
		# The socket reappeared
		debug all systems go
		announce
	    fi
	fi
    done
    
    # the cleanup is done in the trap handler
    exit
}
